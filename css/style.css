@charset "UTF-8";
/*
COLORS:

Light green: #7ed56f
Medium green: #55c57a
Dark green: #28b485

*/
@keyframes moveInLeft {
  0% {
    opacity: 0;
    transform: translateX(-10rem); }
  80% {
    transform: translateX(1rem); }
  100% {
    opacity: 1;
    transform: translateX(0); } }

@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(10rem); }
  80% {
    transform: translateX(-1rem); }
  100% {
    opacity: 1;
    transform: translateX(0); } }

@keyframes moveInBottom {
  0% {
    opacity: 0;
    transform: translateY(3rem); }
  100% {
    opacity: 1;
    transform: translateY(0); } }

*,
*::after,
*::before {
  margin: 0;
  padding: 0;
  box-sizing: inherit; }

html {
  font-size: 62.5%; }

body {
  box-sizing: border-box; }

body {
  font-family: 'Lato', sans-serif;
  font-weight: 400;
  line-height: 1.7;
  color: #777;
  padding: 3rem; }

.heading-primary {
  color: #fff;
  text-transform: uppercase;
  backface-visibility: hidden;
  margin-bottom: 6rem; }
  .heading-primary--main {
    display: block;
    font-size: 6rem;
    font-weight: 400;
    letter-spacing: 3.5rem;
    animation-name: moveInLeft;
    animation-duration: 1s;
    animation-timing-function: ease-out;
    /*
    animation-iteration-count: 3;
    animation-delay: 3s;
    */ }
  .heading-primary--sub {
    display: block;
    font-size: 2rem;
    font-weight: 700;
    letter-spacing: 1.75rem;
    animation: moveInRight 1s ease-out; }

.heading-secondary {
  font-size: 3.5rem;
  text-transform: uppercase;
  font-weight: 700;
  background-image: linear-gradient(to right, #7ed56f, #28b485);
  display: inline-block;
  /* below 'background-clip' and 'color' properties makes the text sit on top of the clipped background (according to the text) therefore we want to make the text invisible so that we can see the gradient through the text*/
  -webkit-background-clip: text;
  color: transparent;
  transition: all 0.2s;
  letter-spacing: 0.2rem; }
  .heading-secondary:hover {
    transform: skewY(2deg) skewX(15deg) scale(1.1);
    text-shadow: 0.5rem 1rem 2rem rgba(0, 0, 0, 0.2); }

.heading-tertiary {
  font-size: 1.6rem;
  font-weight: 700;
  text-transform: uppercase; }

.paragraph {
  font-size: 1.6rem; }
  .paragraph:not(:last-child) {
    margin-bottom: 3rem; }

.u-center-text {
  /* for heading-secondary is an inline-block element and so if we set the parent to text-align center, then that inline block element inside it is treated  as text  and will therefore be centered in the parent*/
  text-align: center !important; }

.u-margin-bottom-big {
  margin-bottom: 8rem !important; }

.u-margin-bottom-medium {
  margin-bottom: 4rem !important; }

.u-margin-bottom-small {
  margin-bottom: 1.5rem !important; }

.u-margin-top-big {
  margin-top: 8rem !important; }

.u-margin-top-huge {
  margin-top: 10rem !important; }

.bg-video {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 100%;
  z-index: -1;
  opacity: 0.15;
  overflow: hidden; }
  .bg-video__content {
    /*This below height and width alone is not going to fix the video not filling up the section area properly
    After setting 
      height: 100%;
      width: 100%;
    the videos width is 100% of the section but it's now covering even less of our section. And that's because it is done to maintain the aspect ratio of this video...So, if it was wider before then of course it also was higher.

    So, what do we do to actually occupy this entire section here, but also while maintaining the aspect ratio?
    use object-fit: cover; property in CSS which is pretty similar to background-size: cover; which we do all the time with the background images (where it tries to cover the entire element with the image)
    */
    height: 100%;
    width: 100%;
    /*Of course it would work just the same with images. And so we can have one parent element and in there an image and then with object-fit: cover; we can make that image cover the parent element*/
    object-fit: cover; }

.btn, .btn:link, .btn:visited {
  text-transform: uppercase;
  text-decoration: none;
  padding: 1.5rem 4rem;
  display: inline-block;
  border-radius: 10rem;
  transition: all 0.2s;
  position: relative;
  font-size: 1.6rem;
  border: none;
  cursor: pointer; }

.btn:hover {
  transform: translateY(-3px);
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.2); }
  .btn:hover::after {
    transform: scaleX(1.4) scaleY(1.6);
    opacity: 0; }

.btn:active, .btn:focus {
  outline: none;
  transform: translateY(-1px);
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.2); }

.btn--white {
  background-color: #fff;
  color: #777; }
  .btn--white::after {
    background-color: #fff; }

.btn--green {
  background-color: #55c57a;
  color: #fff; }
  .btn--green::after {
    background-color: #55c57a; }

.btn::after {
  content: '';
  display: inline-block;
  height: 100%;
  width: 100%;
  border-radius: 10rem;
  position: absolute;
  top: 0;
  left: 0;
  z-index: -1;
  transition: all 0.4s; }

.btn--animated {
  animation: moveInBottom 0.5s ease-out 0.75s;
  animation-fill-mode: backwards; }

.btn-text:link, .btn-text:visited {
  font-size: 1.6rem;
  color: #55c57a;
  display: inline-block;
  text-decoration: none;
  border-bottom: 1px solid #55c57a;
  padding: 3px;
  transition: all 0.2s; }

.btn-text:hover {
  background-color: #55c57a;
  color: #fff;
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.15);
  transform: translateY(-2px); }

.btn-text:active {
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
  transform: translateY(0); }

.card {
  /*The perspective property is used to give a 3D-positioned element some perspective.

  The perspective property defines how far the object is away from the user. So, a lower value will result in a more intensive 3D effect than a higher value.

  When defining the perspective property for an element, it is the CHILD elements that get the perspective view, NOT the element itself, therefore make another div with a class of ".card__side" so that it gets affected because of the perspective property and rotates 180deg along the y-axis with a 3D effect*/
  perspective: 150rem;
  -moz-perspective: 150rem;
  position: relative;
  height: 52rem; }
  .card__side {
    height: 52rem;
    transition: all 0.8s ease;
    position: absolute;
    top: 0;
    left: 0;
    /*now since i gave them an absolute position what the elements do is that they basically start fitting to their width, eg:- in our case the red one is wider than the green one because the word "FRONT" is wider than the word "BACK". We need to change that as well, therefore give them a width.
    
    backface-visibility: <--The backface-visibility property defines whether or not the back face of an element should be visible when facing the user.

    The back face of an element is a mirror image of the front face being displayed.

    This property is useful when an element is rotated. It lets you choose if the user should see the back face or not.*/
    width: 100%;
    backface-visibility: hidden;
    /*The image will later on will overlap the parent element and border-rdius property will not take effect therefore set a property called overflow:hidden (because the image was overflowing the parent in the corners)*/
    border-radius: 3px;
    overflow: hidden;
    box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15);
    /*<div class="card">  <--no longer has a height right now. card__side {.. have a height of 500px like we defined but the card div does not have a height why? its becasue its height collapsed, very similar to what happens when all the elements are floated but right now all the elements are on position: absolute and so they are also taken out of the natural flow and therefore the parent's collapsed and lost its height.
      
      For floats we have clearFix but for position: absolute there is actually no such fix. Therefore we have to specify the same height that we gave for the card__side to the parent (card) itself ie. 50rem*/ }
    .card__side--front {
      background-color: #fff; }
    .card__side--back {
      /*what does it mean that this side is the back side ?
       The difference is that, the back side, in the beginning is already rotated 180deg*/
      transform: rotateY(180deg); }
      .card__side--back-1 {
        background-image: linear-gradient(to right bottom, #ffb900, #ff7730); }
      .card__side--back-2 {
        background-image: linear-gradient(to right bottom, #7ed56f, #28b485); }
      .card__side--back-3 {
        background-image: linear-gradient(to right bottom, #2998ff, #5643fa); }
  .card:hover .card__side--front {
    transform: rotateY(-180deg); }
  .card:hover .card__side--back {
    transform: rotateY(0); }
  .card__picture {
    background-size: cover;
    height: 23rem;
    /*The background-blend-mode property defines how an element's background-image should blend with its background-color:*/
    background-blend-mode: screen;
    -webkit-clip-path: polygon(0 0, 100% 0, 100% 85%, 0 100%);
    clip-path: polygon(0 0, 100% 0, 100% 85%, 0 100%);
    border-top-left-radius: 3px;
    border-top-right-radius: 3px; }
    .card__picture--1 {
      background-image: linear-gradient(to right bottom, #ffb900, #ff7730), url(../img/nat-5.jpg); }
    .card__picture--2 {
      background-image: linear-gradient(to right bottom, #7ed56f, #28b485), url(../img/nat-6.jpg); }
    .card__picture--3 {
      background-image: linear-gradient(to right bottom, #2998ff, #5643fa), url(../img/nat-7.jpg); }
  .card__heading {
    font-size: 2.8rem;
    font-weight: 300;
    text-transform: uppercase;
    color: #fff;
    position: absolute;
    top: 12rem;
    right: 2rem;
    text-align: right;
    width: 75%; }
  .card__heading-span {
    padding: 1rem 1.5rem;
    /*by just adding padding to the entire element the right side of 'A' in the word 'SEA' and the left side of 'E' in the word 'EXPLORER', we dont have any space even after mentioning padding: 1rem 1.5rem why?
    Because this element is treated as one line of text (basically as one element) where the padding gets applied on the left and on the right side, and the left is left side of the 'THE' and the right side is right of the 'EXPLORER' word.
    
    But what we want is to actually treat those two entities ('THE SEA' & 'EXPLORER') like as if they were two different elements and theres actually a way of doing that by using box-decoration-break: clone; */
    -webkit-box-decoration-break: clone;
    box-decoration-break: clone;
    /*what clone does is to simply apply all the decorations that we have in the selector which in this case is only the padding to all of the boxes that are created by an element just like in this case.
    
    So, one element, two boxes and both styled in the same way (with the same padding)*/ }
    .card__heading-span--1 {
      background-image: linear-gradient(to right bottom, rgba(255, 185, 0, 0.85), rgba(255, 119, 48, 0.85)); }
    .card__heading-span--2 {
      background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.85), rgba(40, 180, 133, 0.85)); }
    .card__heading-span--3 {
      background-image: linear-gradient(to right bottom, rgba(41, 152, 255, 0.85), rgba(86, 67, 250, 0.85)); }
  .card__details {
    padding: 3rem; }
    .card__details ul {
      list-style: none;
      width: 80%;
      /*we want this ul with 80% width to be centered in the container. How do we do that ? not absolute positioning or stuff like that but use margin : auto property (we are centering a block element inside of a block element so the simplest way is to simply use margin: 0 auto);*/
      margin: 0 auto; }
      .card__details ul li {
        text-align: center;
        font-size: 1.5rem;
        padding: 1rem; }
        .card__details ul li:not(:last-child) {
          border-bottom: 1px solid #eee; }
  .card__cta {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    text-align: center; }
  .card__price-box {
    text-align: center;
    margin-bottom: 8rem;
    color: #fff; }
  .card__price-only {
    font-size: 1.4rem;
    text-transform: uppercase; }
  .card__price-value {
    font-size: 6rem;
    font-weight: 100; }

.composition {
  position: relative; }
  .composition__photo {
    width: 55%;
    box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.4);
    border-radius: 2px;
    /*as soon as we set the position to absolute on an element these elements will be placed according to a reference and the reference is the first parent that it encounters which has its position set to something and since we want this reference to be the composition, we want it to be positioned according to this composition element (therefore set that to position:relative)
    */
    position: absolute;
    z-index: 10;
    transition: all 0.2s;
    outline-offset: 2rem; }
    .composition__photo--p1 {
      left: 0;
      top: -2rem; }
    .composition__photo--p2 {
      right: 0;
      top: 2rem; }
    .composition__photo--p3 {
      left: 20%;
      top: 10rem; }
    .composition__photo:hover {
      transform: scale(1.05) translateY(-0.5rem);
      box-shadow: 0 2.5rem 4rem rgba(0, 0, 0, 0.5);
      z-index: 20;
      outline: 1.5rem solid #55c57a;
      /* now go to &__photo {....} and set the outline-offset: 2rem; <--and this will give us the space between the outline and the element on which the outline is applied*/ }
  .composition:hover .composition__photo:not(:hover) {
    transform: scale(0.95); }

.feature-box {
  background-color: rgba(255, 255, 255, 0.8);
  font-size: 1.5rem;
  padding: 2.5rem;
  text-align: center;
  border-radius: 3px;
  box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15);
  transition: transform 0.3s; }
  .feature-box__icon {
    font-size: 6rem;
    margin-bottom: 0.5rem;
    display: inline-block;
    background-image: linear-gradient(to right, #7ed56f, #28b485);
    -webkit-background-clip: text;
    color: transparent; }
  .feature-box:hover {
    transform: translateY(-1.5rem) scale(1.03); }

.form__group:not(:last-child) {
  margin-bottom: 2rem; }

.form__input {
  font-size: 1.5rem;
  /*usually all elements automatically inherit the font family but not the input element therefore we set is manually here
    input elements dont inherit font properties
    */
  font-family: inherit;
  color: inherit;
  padding: 1.5rem 2rem;
  border-radius: 2px;
  background-color: rgba(255, 255, 255, 0.5);
  border: none;
  border-bottom: 3px solid transparent;
  width: 90%;
  display: block;
  transition: all 0.3s; }
  .form__input:focus {
    /*we should make the form elements that are focused visible therefore not only remove the default style by outline: none; but also add custom styles like box-shadow and border-bottom like given below*/
    outline: none;
    box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.1);
    border-bottom: 3px solid #55c57a; }
  .form__input:focus:invalid {
    border-bottom: 3px solid #ff7730; }
  .form__input::-webkit-input-placeholder {
    color: #999; }

.form__label {
  font-size: 1.2rem;
  font-weight: 700;
  margin-left: 2rem;
  margin-top: 0.7rem;
  display: block;
  transition: all 0.3s; }

.form__input:placeholder-shown + .form__label {
  /*
      descendant selector (space)
      child selector (>)
      adjacent sibling selector (+)
      general sibling selector (~)
    */
  opacity: 0;
  visibility: hidden;
  transform: translateY(-4rem); }

.form__radio-group {
  width: 49%;
  display: inline-block; }

.form__radio-input {
  display: none; }

.form__radio-label {
  position: relative;
  font-size: 1.6rem;
  cursor: pointer;
  padding-left: 4.5rem; }

.form__radio-button {
  height: 3rem;
  width: 3rem;
  border: 5px solid #55c57a;
  border-radius: 50%;
  display: inline-block;
  position: absolute;
  left: 0;
  top: -0.4rem; }
  .form__radio-button::after {
    content: '';
    display: block;
    width: 1.3rem;
    height: 1.3rem;
    border-radius: 50%;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #55c57a;
    opacity: 0;
    transition: opacity 0.2s; }

.form__radio-input:checked ~ .form__radio-label .form__radio-button::after {
  /*
      descendant selector (space)
      child selector (>)
      adjacent sibling selector (+)
      general sibling selector (~)
    */
  opacity: 1; }

.popup {
  height: 100vh;
  width: 100%;
  position: fixed;
  top: 0;
  left: 0;
  background-color: rgba(0, 0, 0, 0.8);
  z-index: 9999;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s;
  /*Problem :- left element takes up the entire height but the right element only takes up the height it needs (which is shorter than left's height) <--Normal behaviour.
  But we want these two boxes to have the same height because then its easier to center the right elements contents vertically in the middle of all the white space.(very useful technique)

  Therefore not using floats...instead we are going to simulate a table therefore set the display property to display: table-cell; on both of them  (left and right), and then in the parent element which is the "popup__content" set the display property to  display: table;

  Now the browser will automatically give them the same height.
  */ }
  .popup__content {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 75%;
    background-color: #fff;
    box-shadow: 0 2rem 4rem rgba(0, 0, 0, 0.2);
    border-radius: 3px;
    display: table;
    overflow: hidden;
    opacity: 0;
    /*below transform: scale(0.5); will not work and scale the content as expected because we already have a transform: translate(-50%, -50%); property set and we can only have one transform (or one property) in each declaration block therefore  transform: scale(0.5); appears last and it overrides the transform: translate(-50%, -50%); declaration.*/
    transform: translate(-50%, -50%) scale(0.25);
    transition: all 0.5s 0.2s; }
  .popup__left {
    width: 33.333333%;
    display: table-cell; }
  .popup__right {
    width: 66.666666%;
    display: table-cell;
    vertical-align: middle;
    padding: 3rem 5rem; }
  .popup__img {
    display: block;
    width: 100%; }
  .popup__text {
    font-size: 1.5rem;
    margin-bottom: 4rem;
    column-count: 2;
    column-gap: 4rem;
    column-rule: 1px solid #eee;
    -moz-column-count: 2;
    -moz-column-gap: 4rem;
    -moz-column-rule: 1px solid #eee;
    -moz-hyphens: auto;
    -ms-hyphens: auto;
    -webkit-hyphens: auto;
    hyphens: auto; }
  .popup:target {
    opacity: 1;
    visibility: visible; }
  .popup:target .popup__content {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1); }
  .popup__close:link, .popup__close:visited {
    color: #777;
    position: absolute;
    top: 2.5rem;
    right: 2.5rem;
    font-size: 3rem;
    text-decoration: none;
    display: inline-block;
    transition: all 0.2s;
    /* the 'X' element was much higher (because of the line height property) than what we require (it was elongated vertically <--because of the pre-defined line height that we defined)*/
    line-height: 1; }
  .popup__close:hover {
    color: #55c57a; }

.story {
  width: 75%;
  margin: 0 auto;
  box-shadow: 0 3rem 6rem rgba(0, 0, 0, 0.1);
  background-color: rgba(255, 255, 255, 0.6);
  border-radius: 3px;
  padding: 6rem;
  padding-left: 9rem;
  font-size: 1.6rem;
  transform: skewX(-12deg);
  /*
    Direct children
    *figure ("story__shape")
    *div ("story__text")
  */ }
  .story__shape {
    width: 15rem;
    height: 15rem;
    float: left;
    /*The shape-outside property controls how content will wrap around a floated element’s bounding-box. Typically this is so that text can reflow over a shape such as a circle, ellipse or a polygon:*/
    -webkit-shape-outside: circle(50% at 50% 50%);
    shape-outside: circle(50% at 50% 50%);
    -webkit-clip-path: circle(50% at 50% 50%);
    clip-path: circle(50% at 50% 50%);
    /*best way to move around an element that is floated is actually not to mess with margin or anything like that but we should just use a transform*/
    transform: translateX(-3rem) skewX(12deg);
    /* the transform: translateX(-3rem); line pushes the circle into the padding region of the "story" div therefore adjust for that above with padding-left: 9rem (already 6 rem and +3rem to compensate for the translateX(-3rem) circle)*/
    position: relative; }
  .story__image {
    /*the image will take all of the entire space (2000x1333) and thats because we didnt give it a width (also flexible images for responsive web design they always need a width)*/
    /*this image is inside <figure class="story__shape"> which has well defined width and so if we say width: 100%, that will be 100% of the parent therefore 15rem */
    /*the image does not look good because it is wider than its height and so if we gave it a 100% width, then, of course, it cannot fill this entire circle therefore it shouldnt be width: 100% but height: 100%*/
    /*
      width: 100% <-- resized image dimensions = 150 x 99.97 <-- height not sufficient (needed 150px at least)
      height: 100% <-- resized image dimensions = 225.05 x 150 <--both height and width sufficient
    */
    height: 100%;
    /*whenever we are dealing with animations and translating stuff, when something wierd happens then many time backface-visibility: hidden; will fix the issue*/
    transform: translateX(-4rem) scale(1.4);
    transition: all 0.5s;
    backface-visibility: hidden; }
  .story__text {
    transform: skewX(12deg); }
  .story__caption {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, 20%);
    color: #fff;
    text-transform: uppercase;
    font-size: 1.7rem;
    text-align: center;
    opacity: 0;
    transition: all 0.5s;
    backface-visibility: hidden; }
  .story:hover .story__caption {
    opacity: 1;
    transform: translate(-50%, -50%); }
  .story:hover .story__image {
    transform: translateX(-4rem) scale(1);
    filter: blur(3px) brightness(80%); }

.row {
  max-width: 114rem;
  margin: 0 auto; }
  .row:not(:last-child) {
    margin-bottom: 8rem; }
  .row::after {
    content: '';
    display: table;
    clear: both; }
  .row [class^='col-'] {
    float: left; }
    .row [class^='col-']:not(:last-child) {
      margin-right: 6rem; }
  .row .col-1-of-2 {
    width: calc((100% - 6rem) / 2); }
  .row .col-1-of-3 {
    width: calc((100% - 2 *6rem) / 3); }
  .row .col-2-of-3 {
    width: calc( (2 * ((100% - 2 *6rem) / 3)) + 6rem); }
  .row .col-1-of-4 {
    width: calc((100% - 3 *6rem) / 4); }
  .row .col-2-of-4 {
    width: calc( (2 * ((100% - 3 *6rem) / 4)) + 6rem); }
  .row .col-3-of-4 {
    width: calc( (3 * ((100% - 3 *6rem) / 4)) + (2 *6rem)); }

.header {
  height: 95vh;
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url(../img/hero.jpg);
  background-size: cover;
  background-position: top;
  position: relative;
  -webkit-clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%); }
  .header__logo-box {
    position: absolute;
    top: 4rem;
    left: 4rem; }
  .header__logo {
    height: 3.5rem; }
  .header__text-box {
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center; }

.footer {
  background-color: #333;
  padding: 10rem 0;
  font-size: 1.4rem;
  color: #f7f7f7; }
  .footer__logo-box {
    text-align: center;
    margin-bottom: 8rem; }
  .footer__logo {
    width: 15rem;
    height: auto; }
  .footer__navigation {
    border-top: 1px solid #777;
    padding-top: 2rem;
    display: inline-block; }
  .footer__list {
    list-style: none; }
  .footer__item {
    display: inline-block; }
    .footer__item:not(:last-child) {
      margin-right: 1.5rem; }
  .footer__link:link, .footer__link:visited {
    background-color: #333;
    color: #f7f7f7;
    text-decoration: none;
    text-transform: uppercase;
    display: inline-block;
    transition: all 0.2s; }
  .footer__link:hover, .footer__link:active {
    color: #55c57a;
    box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.4);
    transform: rotate(5deg) scale(1.3); }
  .footer__copyright {
    border-top: 1px solid #777;
    padding-top: 2rem;
    width: 80%;
    float: right; }

.navigation__checkbox {
  display: none; }

.navigation__button {
  background-color: #fff;
  height: 7rem;
  width: 7rem;
  /*this circle is diametrically larger than the &__background {.. circle to cover it up and not to expose it earlier on, if it was the same size then we would see some green color of the "navigation__background" behind it but we dont want that, so just to make sure lets completely cover it.*/
  position: fixed;
  top: 6rem;
  right: 6rem;
  border-radius: 50%;
  z-index: 2000;
  box-shadow: 0 1rem 3rem rgba(0, 0, 0, 0.1);
  text-align: center;
  cursor: pointer; }

.navigation__background {
  height: 6rem;
  width: 6rem;
  border-radius: 50%;
  position: fixed;
  top: 6.5rem;
  right: 6.5rem;
  background-image: radial-gradient(#7ed56f, #28b485);
  z-index: 1000;
  /*as soon as the navigation is opened (ie. by checking the checkbox on the top right corner) we will scale this entire background back*/
  transition: transform 0.8s cubic-bezier(0.86, 0, 0.07, 1); }

.navigation__nav {
  /*this would be a huge element occupying the entire viewport so that we can then center the navigation list inside of that, both horizontally and vertically*/
  height: 100vh;
  position: fixed;
  top: 0;
  left: 0;
  /*the button should always remain top but the nav should be on top of the background ie. <nav class="navigation__nav"> should stay in the middle*/
  z-index: 1500;
  /*opacity and width set to zero to remove the navigation__nav completely from the viewport initially and display it when the checkbox is checked*/
  opacity: 0;
  width: 0;
  transition: all 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55); }

.navigation__list {
  /*this is what we are going to center inside of the   &__nav { ... container*/
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  list-style: none;
  text-align: center;
  width: 100%; }

.navigation__item {
  margin: 1rem; }

.navigation__link:link, .navigation__link:visited {
  /*display: inline-block; <-- so that the padding is actually really applied, the way it should and along with the transform: translateX(1rem); to also work*/
  display: inline-block;
  font-size: 3rem;
  font-weight: 300;
  padding: 1rem 2rem;
  color: #fff;
  text-decoration: none;
  text-transform: uppercase;
  background-image: linear-gradient(120deg, transparent 0%, transparent 50%, #fff 50%);
  /*if we increase the background-size: 100%; (<--starting point) property the entire polygon(ie only the white part of it along with the orangered(or transparent) actually) moves to the right and "hides" itself but we can still see the transparent(or orangered) side still...the entire background-image is so big that each anchor tag cant contain it therefore exposing only upto the  transparent 0%, transparent 50%, part of the polygon*/
  /*now all we have to do is to move this entire gradient (polygon) to the left side and then the white part therefore will be visible again <-- this is done only when we hover the anchor element*/
  background-size: 225%;
  transition: all 0.4s; }
  .navigation__link:link span, .navigation__link:visited span {
    margin-right: 1.5rem;
    display: inline-block; }

.navigation__link:hover, .navigation__link:active {
  /*Shift the background (gradient) completely to the left side now, then we will end up with the effect that we want*/
  /*when we hover it, the background (gradient) basically shifts to the left side because the position is now at 100%*/
  /*if we reduce the background-position: 100%; value, the white part of the polygon (along with the transparent(or orangered) actually) moves to the right side, basically hiding itself again*/
  /*The background-position property sets the starting position of a background image.

      Tip: By default, a background-image is placed at the top-left corner of an element, and repeated both vertically and horizontally.
      
      x% y%	--> The first value is the horizontal position and the second value is the vertical. 

      */
  background-position: 100%;
  color: #55c57a;
  transform: translateX(1rem); }

.navigation__checkbox:checked ~ .navigation__background {
  transform: scale(80); }

.navigation__checkbox:checked ~ .navigation__nav {
  opacity: 1;
  width: 100%; }

.navigation__icon {
  position: relative;
  margin-top: 3.5rem; }
  .navigation__icon, .navigation__icon::before, .navigation__icon::after {
    width: 3rem;
    height: 2px;
    background-color: #333;
    display: inline-block; }
  .navigation__icon::before, .navigation__icon::after {
    content: '';
    position: absolute;
    left: 0;
    transition: all 0.2s; }
  .navigation__icon::before {
    top: -0.8rem;
    /*what transform-origin: right; does is, it says that the center of the rotation is on the right side of the element (like a Windscreen wiper).
      
      If we dont specify this at all then its basically rotates around the center*/ }
  .navigation__icon::after {
    top: 0.8rem; }

.navigation__button:hover .navigation__icon::before {
  /*
    <label for="navi-toggle" class="navigation__button">
        <span class="navigation__icon">&nbsp;</span>
      </label>
    */
  top: -1rem; }

.navigation__button:hover .navigation__icon::after {
  /*
    <label for="navi-toggle" class="navigation__button">
        <span class="navigation__icon">&nbsp;</span>
      </label>
    */
  top: 1rem; }

.navigation__checkbox:checked + .navigation__button .navigation__icon {
  /*
      <input type="checkbox" id="navi-toggle" class="navigation__checkbox" />
      <label for="navi-toggle" class="navigation__button">
          <span class="navigation__icon">&nbsp;</span>
      </label>
    */
  /* this one we want to make it disappear, but we dont want to really change its size because the after and before pseudo elements depend on this elements(middle one) size. They are positioned in relation to that size and if we now remove that size (width and the height) of this element(middle one) then we would change the positions of the before and after...and we dont want that. Therefore just change the background color */
  background-color: transparent; }

.navigation__checkbox:checked + .navigation__button .navigation__icon::before {
  top: 0;
  transform: rotate(135deg); }

.navigation__checkbox:checked + .navigation__button .navigation__icon::after {
  top: 0;
  transform: rotate(-135deg); }

.section-about {
  background-color: #f7f7f7;
  padding: 25rem 0;
  /*why margin-top: -20vh ? because  header height: 95vh; and clip-path: polygon(0 0, 100% 0, 100% --> 75vh <--, 0 100%); 95vh -75vh = 20vh (to kind of move up this section to hide the white triangle)*/
  margin-top: -20vh; }

.section-features {
  padding: 20rem 0;
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url(../img/nat-4.jpg);
  /*cover:-	Resize the background image to cover the entire container, even if it has to stretch the image or cut a little bit off one of the edges*/
  background-size: cover;
  transform: skewY(-7deg);
  margin-top: -11.3rem; }
  .section-features > * {
    transform: skewY(7deg); }

.section-tours {
  background-color: #f7f7f7;
  padding: 25rem 0 15rem 0;
  margin-top: -11.3rem; }

.section-stories {
  position: relative;
  padding: 15rem 0; }

.section-book {
  padding: 15rem 0;
  background-image: linear-gradient(to right bottom, #7ed56f, #28b485); }

.book {
  background-image: linear-gradient(105deg, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.9) 50%, transparent 50%), url(../img/nat-10.jpg);
  /*background-size: cover===100%; because cover stretches the image to occupy the entire container where the background image is applied and thats what 100% does*/
  background-size: 100%;
  border-radius: 3px;
  box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.25);
  height: 50rem; }
  .book__form {
    width: 50%;
    padding: 6rem; }
